// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part of the xpcc library and is released under the 3-clause BSD
* license. See the file `LICENSE` for the full license governing this code.
*/
// ----------------------------------------------------------------------------

#ifndef XPCC_STM32_SIMPLE_SPI{{ id }}_HPP
#	error	"Don't include this file directly, use 'simple_spi.hpp' instead!"
#endif

// ----------------------------------------------------------------------------
template< class clockSource, uint32_t baudrate >
void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::initialize()
{
	static_assert(clockSource::Spi{{ id }}/2 >= baudrate,
		"The peripheral frequency must be at least 2x higher than SPI baudrate.");
	static_assert(clockSource::Spi{{ id }}/256 <= baudrate,
		"The SPI baudrate must be at most 256x lower than peripheral frequency.");

	constexpr uint16_t pre_raw = (clockSource::Spi{{ id }} / baudrate);
	SpiHal{{ id }}::Prescaler prescaler = SpiHal{{ id }}::Prescaler::Div256;
	if (pre_raw >= 256) {
		prescaler = SpiHal{{ id }}::Prescaler::Div256;
	}
	else if (pre_raw >= 128) {
		prescaler = SpiHal{{ id }}::Prescaler::Div128;
	}
	else if (pre_raw >= 64) {
		prescaler = SpiHal{{ id }}::Prescaler::Div64;
	}
	else if (pre_raw >= 32) {
		prescaler = SpiHal{{ id }}::Prescaler::Div32;
	}
	else if (pre_raw >= 16) {
		prescaler = SpiHal{{ id }}::Prescaler::Div16;
	}
	else if (pre_raw >= 8) {
		prescaler = SpiHal{{ id }}::Prescaler::Div8;
	}
	else if (pre_raw >= 4) {
		prescaler = SpiHal{{ id }}::Prescaler::Div4;
	}
	else {
		prescaler = SpiHal{{ id }}::Prescaler::Div2;
	}

	SpiHal{{ id }}::initialize(prescaler);
	finished = true;
}

void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::setDataMode(DataMode mode)
{
	SpiHal{{ id }}::setDataMode(static_cast<SpiHal{{ id }}::DataMode>(mode));
}

void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::setDataOrder(DataOrder order)
{
	SpiHal{{ id }}::setDataOrder(static_cast<SpiHal{{ id }}::DataOrder>(order));
}

uint8_t ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::writeReadBlocking(uint8_t data)
{
	writeBlocking(data);
	while(!getResult(data))
		;
	return data;
}

void ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::writeBlocking(uint8_t data)
{
	while(!isFinished())
		;
	SpiHal{{ id }}::write(data);
}

bool ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::write(uint8_t data)
{
	if(!isFinished())
		return false;

	SpiHal{{ id }}::write(data);
	return true;
}

bool ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::getResult(uint8_t &data)
{
	if (!SpiHal{{ id }}::isReceiveRegisterNotEmpty())
		return false;

	SpiHal{{ id }}::read(data);
	return true;
}

bool ALWAYS_INLINE
xpcc::stm32::SpiSimpleMaster{{ id }}::isFinished()
{
	return SpiHal{{ id }}::isTransmitRegisterEmpty() && finished;
}
